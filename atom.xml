<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiannanh.github.io</id>
    <title>Jiannan</title>
    <updated>2020-08-30T08:52:13.575Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiannanh.github.io"/>
    <link rel="self" href="https://jiannanh.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiannanh.github.io/images/avatar.png</logo>
    <icon>https://jiannanh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Jiannan</rights>
    <entry>
        <title type="html"><![CDATA[leetcode -string 1]]></title>
        <id>https://jiannanh.github.io/post/leetcode-string-1/</id>
        <link href="https://jiannanh.github.io/post/leetcode-string-1/">
        </link>
        <updated>2020-08-30T08:49:35.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>题号</th>
<th>我的代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>28</td>
<td><a href="#"> Implement strStr()</a></td>
</tr>
<tr>
<td>14</td>
<td><a href="#">Longest Common Prefix </a></td>
</tr>
<tr>
<td>58</td>
<td><a href="#"> Length of Last Word</a></td>
</tr>
<tr>
<td>387</td>
<td><a href="#">First Unique Character in a String </a></td>
</tr>
<tr>
<td>383</td>
<td><a href="#">	Ransom Note </a></td>
</tr>
<tr>
<td>344</td>
<td><a href="#">Reverse String </a></td>
</tr>
<tr>
<td>151</td>
<td><a href="#"> Reverse Words in a String</a></td>
</tr>
<tr>
<td>186</td>
<td><a href="#">Reverse Words in a String II </a></td>
</tr>
<tr>
<td>345</td>
<td><a href="#">	Reverse Vowels of a String </a></td>
</tr>
<tr>
<td>205</td>
<td><a href="#">	Isomorphic Strings</a></td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
<h2 id=""></h2>
<pre><code>
</code></pre>
<p><a href=""></a></p>
<pre><code class="language-java">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode - Array 2]]></title>
        <id>https://jiannanh.github.io/post/leetcode-array-2/</id>
        <link href="https://jiannanh.github.io/post/leetcode-array-2/">
        </link>
        <updated>2020-08-27T12:30:15.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>题号</th>
<th>我的代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>121</td>
<td><a href="#best-time-to-buy-and-sell-stock">Best Time to Buy and Sell Stock</a></td>
</tr>
<tr>
<td>122</td>
<td><a href="#best-time-to-buy-and-sell-stock-ii">Best Time to Buy and Sell Stock II</a></td>
</tr>
<tr>
<td>123</td>
<td><a href="#best-time-to-buy-and-sell-stock-iii">Best Time to Buy and Sell Stock III</a></td>
</tr>
<tr>
<td>188</td>
<td><a href="#best-time-to-buy-and-sell-stock-iv">Best Time to Buy and Sell Stock IV</a></td>
</tr>
<tr>
<td>309</td>
<td><a href="#best-time-to-buy-and-sell-stock-with-cooldown">Best Time to Buy and Sell Stock with Cooldown</a></td>
</tr>
<tr>
<td>11</td>
<td><a href="#container-with-most-water">Container With Most Water </a></td>
</tr>
<tr>
<td>42</td>
<td><a href="#trapping-rain-water"> Trapping Rain Water</a></td>
</tr>
<tr>
<td>334</td>
<td><a href="#increasing-triplet-subsequence">Increasing Triplet Subsequence</a></td>
</tr>
<tr>
<td>128</td>
<td><a href="#longest-consecutive-sequence">Longest Consecutive Sequence</a></td>
</tr>
<tr>
<td></td>
<td><a href="#"> </a></td>
</tr>
<tr>
<td></td>
<td><a href="#"> </a></td>
</tr>
<tr>
<td></td>
<td><a href="#"> </a></td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
<h2 id="best-time-to-buy-and-sell-stock">Best Time to Buy and Sell Stock</h2>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<pre><code>Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">121. Best Time to Buy and Sell Stock</a></p>
<pre><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        int min = Integer.MAX_VALUE;
        for (int n : prices) {
            if (n &lt; min) {
                min = n;
            }
            res = Math.max(res, n - min);
        }
        return res;
    }
}
</code></pre>
<h2 id="best-time-to-buy-and-sell-stock-ii">Best Time to Buy and Sell Stock II</h2>
<p>Say you have an array prices for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<pre><code>Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre>
<p>Constraints:</p>
<p>1 &lt;= prices.length &lt;= 3 * 10 ^ 4<br>
0 &lt;= prices[i] &lt;= 10 ^ 4</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></p>
<pre><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i] &gt; prices[i - 1]) {
                res += prices[i] - prices[i - 1];
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="best-time-to-buy-and-sell-stock-iii">Best Time to Buy and Sell Stock III</h2>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<pre><code>Example 1:

Input: prices = [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
Example 2:

Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
Example 4:

Input: prices = [1]
Output: 0
</code></pre>
<p>Constraints:<br>
1 &lt;= prices.length &lt;= 105<br>
0 &lt;= prices[i] &lt;= 105</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/">123. Best Time to Buy and Sell Stock III </a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="best-time-to-buy-and-sell-stock-iv">Best Time to Buy and Sell Stock IV</h2>
<p>Say you have an array for which the i-th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:<br>
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<pre><code>Example 1:

Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
Example 2:

Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
</code></pre>
<p>Constraints:<br>
1 &lt;= prices.length &lt;= 105<br>
0 &lt;= prices[i] &lt;= 105</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">123. Best Time to Buy and Sell Stock IV</a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="best-time-to-buy-and-sell-stock-with-cooldown">Best Time to Buy and Sell Stock with Cooldown</h2>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br>
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</p>
<pre><code>Example:

Input: [1,2,3,0,2]
Output: 3 
Explanation: transactions = [buy, sell, cooldown, buy, sell]
</code></pre>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. Best Time to Buy and Sell Stock with Cooldown</a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="container-with-most-water">Container With Most Water</h2>
<p>Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<pre><code>Example:
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
</code></pre>
<p><a href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water</a></p>
<pre><code class="language-java">class Solution {
    public int maxArea(int[] height) {
        int res = 0;
        int i = 0;
        int j = height.length - 1;
        while (i &lt; j) {
            if (height[i] &gt; height[j]) {
                res = Math.max(res, height[j] * (j - i));
                j--;
            } else {
                res = Math.max(res, height[i] * (j - i));
                i++;
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="trapping-rain-water">Trapping Rain Water</h2>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<pre><code>Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
</code></pre>
<p><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a></p>
<pre><code class="language-java">class Solution {
    public int trap(int[] height) {
        int l = 0;
        int r = height.length -1;
        int lmax = Integer.MIN_VALUE;
        int rmax = Integer.MIN_VALUE;
        int res = 0;
        while (l &lt;= r) {
            if (lmax &gt; rmax) {
                rmax = Math.max(rmax, height[r]);
                res += rmax - height[r];
                r--;
            } else {
                lmax = Math.max(lmax, height[l]);
                res += lmax - height[l];
                l++;
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="increasing-triplet-subsequence">Increasing Triplet Subsequence</h2>
<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<p>Return true if there exists i, j, k<br>
such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.<br>
Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<pre><code>Example 1:

Input: [1,2,3,4,5]
Output: true
Example 2:

Input: [5,4,3,2,1]
Output: false
</code></pre>
<p><a href="https://leetcode.com/problems/increasing-triplet-subsequence/">334. Increasing Triplet Subsequence</a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="longest-consecutive-sequence">Longest Consecutive Sequence ！！！</h2>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<pre><code>Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
</code></pre>
<p><a href="https://leetcode.com/problems/longest-consecutive-sequence/">128. Longest Consecutive Sequence</a></p>
<pre><code class="language-java">class Solution {
    public int longestConsecutive(int[] nums) {
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int n : nums) {
            set.add(n);
        }
        int res = 0;
        for (int n : nums) {
            int down = n - 1;
            while (set.contains(down)) {
                set.remove(down);
                down--;
            }
            int up = n + 1;
            while (set.contains(up)) {
                set.remove(up);
                up++;
            }
            res = Math.max(res, up - down - 1);
        }
        return res;
    }
}
</code></pre>
<h2 id="maximum-gap-桶排序和基数排序">Maximum Gap - 桶排序和基数排序</h2>
<p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<pre><code>Example 1:

Input: [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either
             (3,6) or (6,9) has the maximum difference 3.
Example 2:

Input: [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.
</code></pre>
<p>Note:<br>
You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>
Try to solve it in linear time/space.<br>
<a href="https://leetcode.com/problems/maximum-gap/description/">Maximum Gap</a></p>
<pre><code class="language-java">
</code></pre>
<h2 id=""></h2>
<pre><code>
</code></pre>
<p><a href=""></a></p>
<pre><code class="language-java">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gRPC-web]]></title>
        <id>https://jiannanh.github.io/post/cong-ling-kai-shi-grpc/</id>
        <link href="https://jiannanh.github.io/post/cong-ling-kai-shi-grpc/">
        </link>
        <updated>2020-08-17T12:27:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rpc-是什么">RPC 是什么？</h1>
<h2 id="1-rpc是什么">1. RPC是什么</h2>
<blockquote>
<p>在分布式计算中，远程过程调用（RPC）是指计算机程序使过程（子例程）在不同的地址空间（通常在共享网络的另一台计算机上）执行时，远程的过程就像是普通的（本地）调用，而无需程序员为远程过程写过多的代码。即，无论子例程是正在执行的程序是本地程序还是远程程序，程序员都编写基本相同的代码。这是客户端-服务器交互的一种形式（客户端调用，服务器执行），通常是通过请求-响应消息传递系统来实现的。在面向对象的编程语言（JAVA）中，RPC由远程方法调用表示（RMI）。RPC模型意味着一定程度的位置透明性，即无论本地还是远程，调用过程在很大程度上是相同的，但是实质上它们并不相同，（感受上很像是在本地，但是实际上是在远程调用）因此可以将本地调用与远程调用区分开。<br>
远程呼叫通常比本地呼叫慢几个数量级，并且可靠性较差，因此区分它们很重要。（但是实际应用中，前后端是分离的，这样的比较对rpc来说并不公平）<br>
<a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call</a></p>
</blockquote>
<p>从上面的 Wiki 中可以看出 RPC 更多像是一种概念。目前，RPC 这种概念已经被许多不同的（通常是不兼容的）技术已被用来实现。包括gRPC。</p>
<h3 id="为什么选择grpc-web">为什么选择gRPC-web？</h3>
<p>gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过插件来支持有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后步骤，以将设备，移动应用程序和浏览器连接到后端服务。</p>
<p>到目前为止，这些好处基本上仅适用于移动应用程序和后端开发人员，而前端开发人员则不得不继续依赖JSON REST接口作为其主要的信息交换手段。但是，随着gRPC-Web的发布，gRPC有望成为前端开发人员工具箱中的宝贵补充。<a href="https://grpc.io/blog/state-of-grpc-web/">link</a></p>
<p>在我看来，gRPC-Web的优点在于，它使您能够从Web客户端一直创建完整的端到端gRPC服务体系结构。您只需要在.proto文件中一次定义服务。以前，如果您想将gRPC驱动的后端与Web客户端结合使用，则需要编写REST API逻辑来与gRPC进行HTTP调用之间的转换-我们大多数人都愿意避免的工作。gRPC-Web使您能够直接使用协议缓冲区封装所有数据接口，从而使您不必再编写其他HTTP服务器。<a href="https://blog.envoyproxy.io/envoy-and-grpc-web-a-fresh-new-alternative-to-rest-6504ce7eb880">link</a></p>
<p>还将获得使用协议缓冲区的所有优点，包括高效的序列化，简单的IDL和轻松的接口更新。gRPC-Web使您可以使用惯用的API从浏览器访问以这种方式构建的gRPC服务。</p>
<h3 id="grpc的四个优点">gRPC的四个优点</h3>
<ol>
<li>简单的服务定义<br>
使用 Protocol Buffer 这种强大的二进制序列化工具来定义服务。</li>
<li>快速启动和扩展<br>
只需要一行命令即可安装运行时和开发环境。此外，使用此框架每秒可以扩展数百万个 RPC</li>
<li>跨语言和平台工作<br>
用你惯用的语言自动地生成client和service</li>
<li>双向流和集成身份验证<br>
以HTTP/2为基础的双向流和插件化认证</li>
</ol>
<h2 id="rpc-模块-如何搭建一个-rpc">RPC 模块 - 如何搭建一个 RPC</h2>
<p>通信经过网络，传统的单体应用要通过接口。远程的方法是如何使用的。我也可以把远程的方法变成接口。通过代理技术。在调用的过程中，对方法进行拦截，对参数进行序列化。在序列化的过程中，拿到目标地址。编解码后，传到网络上。目标地址监听网络，拿到数据包进行解码，拿到二进制数据进行反序列化。通过反射执行。通过相反的路传回给调用方。调用方获得结果。<br>
<img src="https://jiannanh.github.io/post-images/1597113191937.png" alt="" loading="lazy"></p>
<h2 id="rpc架构">RPC架构</h2>
<figure data-type="image" tabindex="1"><img src="https://jiannanh.github.io/post-images/1597113273813.png" alt="" loading="lazy"></figure>
<h2 id="grpc-web-架构">gRPC-web 架构</h2>
<p><img src="https://jiannanh.github.io/post-images/1597809413017.png" alt="" loading="lazy"><br>
<img src="https://jiannanh.github.io/post-images/1597809418373.png" alt="" loading="lazy"></p>
<h2 id="2-restful-和-rpc">2. Restful 和 RPC</h2>
<p>RPC是面向过程，RESTful 是面向资源也就是 url，并且使用了 HTTP 操作。从这个维度上看，RESTful风格的 url 在表述的精简性、可读性上都要更好。</p>
<p>其他的诸如，协议版本，RPC 中的代理序列化等差异。我个人觉得只是实现上的区别。</p>
<h2 id="为什么要用-rpc-grpc-web">为什么要用 RPC || gRPC-web</h2>
<p>最开始应用都是单体的应用，开发比较简单，但程序部署比较麻烦。如果有一个环节出了问题，也可以比较快的横向扩展。大的应用之间的通信需要使用rpc进行通信。</p>
<p>开发模式的提升，就像是前后端分离的理念细化了分工，提升了效率和代码质量。gRPC-web （或许）能节约对接口的复杂过程。对接多个不同语言代码的后端。所有的语言共一个接口写法。</p>
<h2 id="quick-start">Quick start</h2>
<p>谈了这么多的 RPC-web 的好处，接下来有两个小 case可以快速的感受 RPC-web 的实际效果。</p>
<p>首先是 gRPC-web 的<a href="https://grpc.io/docs/languages/web/quickstart/">官方demo</a>这个demo 跑起来很方便，但是整个 demo 和 gRPC-web 的其他文件放在了一起，RPC-web 的主要功能反而不好发现。</p>
<p>第二个是一个，React gRPC-web 的 demo，这个项目比较简单，也能更好的体会到核心的几个功能模块。比如 protoc，protoc-web，envoy代理，和 docker 等。<br>
<img src="https://jiannanh.github.io/post-images/1597807417559.jpeg" alt="" loading="lazy"></p>
<p>在开始之前，请确保已安装以下组件：</p>
<ol>
<li>npm (Node package manager) - For generating react project <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025597810528">download</a></li>
<li>Docker - For running envoy locally <a href="https://www.docker.com/get-started">download</a></li>
<li>protoc - For generating code using protos <a href="https://github.com/protocolbuffers/protobuf/releases">download</a><br>
protoc 的 exe 文件是下面这些。<strong>不要</strong>下载其他的文件。<br>
protoc-3.13.0-osx-x86_64.zip<br>
protoc-3.13.0-win64.zip</li>
<li>下载 protoc-gen-grpc-web 插件 <a href="https://github.com/grpc/grpc-web/releases">download</a></li>
</ol>
<p><strong>一定一定</strong>要记得把文件放到 PATH 中。<br>
MacOS, 可以这样:</p>
<pre><code>$ sudo mv ~/Downloads/protoc-gen-grpc-web-1.2.1-darwin-x86_64 \
    /usr/local/bin/protoc-gen-grpc-web
$ chmod +x /usr/local/bin/protoc-gen-grpc-web
</code></pre>
<p>1.用户界面-网站使用react<br>
为了创建一个React项目，我们将使用create-react-app命令。</p>
<p>create-react-app learn-react-grpc<br>
现在我们已经有了一个示例项目，让我们创建一个原型。这就是乒乓球的原型。</p>
<pre><code>syntax = &quot;proto3&quot;;

package pingpong;

message PingRequest {
    string ping = 1;
}

message PongResponse {
    string pong = 1;
}

service PingPongService {
    rpc pingPong(PingRequest) returns (PongResponse);
}
</code></pre>
<p>要运行后续命令，请确保原型位于react项目的src /文件夹中。要在javascript中生成客户端代码，请运行以下命令：</p>
<pre><code>protoc -I=. src/ping_pong.proto --js_out=import_style=commonjs:. --grpc-web_out=import_style=commonjs,mode=grpcwebtext:.
</code></pre>
<p>这将生成两个新文件：* ping_pong_pb.js *和ping_pong_grpc_web_pb.js，其中包含所有生成的代码。我们将使用此代码向我们的gRPC服务发出请求。</p>
<p>首先，让我们使用一些与gRPC和protobuf相关的依赖项更新package.json，然后运行npm install <em>。</em></p>
<pre><code class="language-json">{
      &quot;name&quot;: &quot;learn-react-grpc&quot;,
      &quot;version&quot;: &quot;0.1.0&quot;,
      &quot;private&quot;: true,
      &quot;dependencies&quot;: {
        &quot;react&quot;: &quot;^16.8.6&quot;,
        &quot;react-dom&quot;: &quot;^16.8.6&quot;,
        &quot;react-scripts&quot;: &quot;2.1.8&quot;,
        &quot;@grpc/grpc-js&quot;: &quot;^0.3.6&quot;,
        &quot;google-protobuf&quot;: &quot;^3.7.1&quot;,
        &quot;grpc&quot;: &quot;^1.19.0&quot;,
        &quot;grpc-web&quot;: &quot;^1.0.4&quot;
      },
      &quot;scripts&quot;: {
        &quot;start&quot;: &quot;react-scripts start&quot;,
        &quot;build&quot;: &quot;react-scripts build&quot;,
        &quot;test&quot;: &quot;react-scripts test&quot;,
        &quot;eject&quot;: &quot;react-scripts eject&quot;
      },
      &quot;eslintConfig&quot;: {
        &quot;extends&quot;: &quot;react-app&quot;
      },
      &quot;browserslist&quot;: [
        &quot;&gt;0.2%&quot;,
        &quot;not dead&quot;,
        &quot;not ie &lt;= 11&quot;,
        &quot;not op_mini all&quot;
      ]
    }
</code></pre>
<p>以下是构建我们的网站的全部逻辑。您可以在App.js文件中使用此代码。这是一个非常简单的网站，其中包含一个按钮，单击可创建一个乒乓球请求并获得响应。</p>
<pre><code class="language-js">import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';


const { PingPongServiceClient } = require('./ping_pong_grpc_web_pb');
const { PingRequest, PongResponse } = require('./ping_pong_pb.js');


var client = new PingPongServiceClient('http://localhost:9090', null, null);


class App extends Component {

  callGrpcService = () =&gt; {
    const request = new PingRequest();
    request.setPing('Ping');


    client.pingPong(request, {}, (err, response) =&gt; {
      if (response == null) {
        console.log(err)
      } else {
        console.log(response.getPong())
      }
    });
  }


  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;header className=&quot;App-header&quot;&gt;
          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;
          &lt;button style={{ padding: 10 }} onClick={this.callGrpcService}&gt;Click for grpc request&lt;/button&gt;
        &lt;/header&gt;
      &lt;/div&gt;
    );
  }
}

export default App;
</code></pre>
<p>现在，如果您使用npm start运行节点服务器，那么您很可能会遇到此编译问题。将gRPC-web与通过* create-react-app *命令行界面创建的项目一起使用时，这显然是一个问题。<br>
<img src="https://jiannanh.github.io/post-images/1597808817596.png" alt="" loading="lazy"></p>
<p>但是，可以通过向所有原型生成的文件添加eslint-disable *来解决此问题。确保对所有文件都执行此操作。现在，如果您启动服务器，一切都应该正常工作。</p>
<figure data-type="image" tabindex="2"><img src="https://jiannanh.github.io/post-images/1597808828467.png" alt="" loading="lazy"></figure>
<p>2.后端-Node中的gRPC服务器<br>
让我们创建一个简单的节点服务器。我们将使用与React应用中相同的原型。让我们创建一个节点js应用程序node-ping-pong-server。这是我们的示例server.js文件。</p>
<pre><code class="language-js">var grpc = require('grpc');
var pingPongProto = grpc.load('ping_pong.proto');
var server = new grpc.Server();


server.addService(pingPongProto.pingpong.PingPongService.service, {
  pingPong: function (call, callback) {
    console.log(&quot;Request&quot;)
    return callback(null, { pong: &quot;Pong&quot; })
  }
});


server.bind('localhost:8080', grpc.ServerCredentials.createInsecure());
server.start();
</code></pre>
<p>我们可以使用以下命令运行节点服务器：</p>
<pre><code class="language-js">node server.js
</code></pre>
<p>3.代理人-特使<br>
如上所述，我们将使用Docker来设置特使。这是docker文件。在撰写本文时，最新标签指向Envoy * 1.11版。*在您的应用程序的src /文件夹中创建一个Dockerfile。</p>
<pre><code class="language-docker">FROM envoyproxy/envoy-dev:latest

COPY ./envoy.yaml /etc/envoy/envoy.yaml

CMD /usr/local/bin/envoy -c /etc/envoy/envoy.yaml -l trace --log-path /tmp/envoy_info.log
</code></pre>
<p>在运行Docker容器之前，我们需要确保有一个用于envoy的配置文件。将此envoy.yml添加到react应用的src /文件夹中。</p>
<pre><code class="language-yaml">admin:
  access_log_path: /tmp/admin_access.log
  address:
    socket_address: { address: 0.0.0.0, port_value: 9901 }

static_resources:
  listeners:
  - name: listener_0
    address:
      socket_address: { address: 0.0.0.0, port_value: 9090 }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          &quot;@type&quot;: type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: local_service
              domains: [&quot;*&quot;]
              routes:
              - match: { prefix: &quot;/&quot; }
                route:
                  cluster: ping_pong_service
                  max_grpc_timeout: 0s
              cors:
                allow_origin_string_match:
                - prefix: &quot;*&quot;
                allow_methods: GET, PUT, DELETE, POST, OPTIONS
                allow_headers: keep-alive,user-agent,cache-control,content-type,content-transfer-encoding,custom-header-1,x-accept-content-transfer-encoding,x-accept-response-streaming,x-user-agent,x-grpc-web,grpc-timeout
                max_age: &quot;1728000&quot;
                expose_headers: custom-header-1,grpc-status,grpc-message
          http_filters:
          - name: envoy.filters.http.grpc_web
          - name: envoy.filters.http.cors
          - name: envoy.filters.http.router
  clusters:
  - name: ping_pong_service
    connect_timeout: 0.25s
    type: logical_dns
    http2_protocol_options: {}
    lb_policy: round_robin
    hosts: [{ socket_address: { address: host.docker.internal, port_value: 8080 }}]
</code></pre>
<p>现在，使用以下命令构建我们的Docker映像：</p>
<pre><code>docker build -t mohak1712/learn-grpc-web .
</code></pre>
<p>现在让我们运行docker镜像：</p>
<pre><code>docker run -d -p 9090:9090 mohak1712/learn-grpc-web
</code></pre>
<p>我们需要将主机端口9090转发到容器端口9090，以便将端口9090上的任何请求转发到运行envoy的docker容器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode - Array 1]]></title>
        <id>https://jiannanh.github.io/post/leetcode-array/</id>
        <link href="https://jiannanh.github.io/post/leetcode-array/">
        </link>
        <updated>2020-08-12T08:26:56.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>题号</th>
<th>我的代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>27</td>
<td><a href="#remove-element">Remove Element</a></td>
</tr>
<tr>
<td>134</td>
<td><a href="#gas-station">Gas Station </a></td>
</tr>
<tr>
<td>118</td>
<td><a href="#pascals-triangle">Pascal's Triangle</a></td>
</tr>
<tr>
<td>119</td>
<td><a href="#pascals-triangle-ii">Pascal's Triangle II</a></td>
</tr>
<tr>
<td>169</td>
<td><a href="#majority-element">Majority Element</a></td>
</tr>
<tr>
<td>274</td>
<td><a href="#h-index">H-Index</a></td>
</tr>
<tr>
<td>275</td>
<td><a href="#h-index-ii">H-Index II</a></td>
</tr>
<tr>
<td>243</td>
<td><a href="#shortest-word-distance">Shortest Word Distance</a></td>
</tr>
<tr>
<td>244</td>
<td><a href="#shortest-word-distance-ii">Shortest Word Distance II</a></td>
</tr>
<tr>
<td>245</td>
<td><a href="#shortest-word-distance-iii">Shortest Word Distance III</a></td>
</tr>
<tr>
<td>217</td>
<td><a href="#contains-duplicate">Contains Duplicate</a></td>
</tr>
<tr>
<td>219</td>
<td><a href="#contains-duplicate-ii">Contains Duplicate II </a></td>
</tr>
<tr>
<td>220</td>
<td><a href="#contains-duplicate-iii">Contains Duplicate III </a></td>
</tr>
<tr>
<td>55</td>
<td><a href="#jump-game">Jump Game</a></td>
</tr>
<tr>
<td>45</td>
<td><a href="#jump-game-ii">Jump Game II</a></td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
<h2 id="remove-element">Remove Element</h2>
<p><a href="https://leetcode.com/problems/remove-element/">27 Remove Element </a></p>
<pre><code class="language-java">class Solution {
    public int removeElement(int[] nums, int val) {
        int res = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] != val) {
                nums[res++] = nums[i];
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="gas-station">Gas Station</h2>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.<br>
<a href="https://leetcode.com/problems/gas-station/">134. Gas Station </a></p>
<pre><code class="language-java">class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int sum = 0;
        int start = 0;
        for (int i = 0; i &lt; gas.length; i++) {
            sum += gas[i] - cost[i];
        }
        if (sum &lt; 0) {
            return -1;
        } else {
            sum = 0;
            for (int i = 0; i &lt; gas.length; i++) {
                if (sum &lt; 0) {
                    start = i;
                    sum = gas[i] - cost[i];
                } else  {
                    sum += gas[i] - cost[i];
                }
            }
        }
        return start;
    }
}
</code></pre>
<h2 id="pascals-triangle">Pascal's Triangle</h2>
<p><a href="https://leetcode.com/problems/pascals-triangle/description/">118. Pascal's Triangle</a></p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; numRows; i++) {
            list.add(0, 1);
            for (int j = 1; j &lt; list.size() - 1; j++) {
                list.set(j, list.get(j) + list.get(j + 1));
            }
            res.add(new ArrayList&lt;&gt;(list));
        }
        return res;
    }
}
</code></pre>
<h2 id="pascals-triangle-ii">Pascal's Triangle II</h2>
<p><a href="https://leetcode.com/problems/pascals-triangle-ii/description/">119. Pascal's Triangle II</a></p>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; getRow(int rowIndex) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt;= rowIndex; i++) {
            list.add(0, 1);
            for (int j = 1; j &lt; list.size() - 1; j++) {
                list.set(j, list.get(j) + list.get(j + 1));
            }
        }
        return list;
    }
}
</code></pre>
<h2 id="majority-element">Majority Element</h2>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.<br>
<a href="https://leetcode.com/problems/majority-element/">169. Majority Element</a></p>
<pre><code class="language-java">class Solution {
    public int majorityElement(int[] nums) {
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            if (map.containsKey(nums[i])) {
                map.put(nums[i], map.get(nums[i]) + 1);
            } else {
                map.put(nums[i], 1);
            }
        }
        for (int i = 0; i &lt; nums.length; i++) {
            if (map.get(nums[i]) &gt; nums.length/2) {
                return nums[i];
            }
        }
        return -1;
    }
}
</code></pre>
<h2 id="majority-element-2">Majority Element</h2>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.<br>
<a href="https://leetcode.com/problems/majority-element-ii/">229. Majority Element II</a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="h-index">H-Index</h2>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.<br>
<a href="https://leetcode.com/problems/h-index/description/">274. H-Index</a></p>
<pre><code class="language-java">class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int res = 0;
        for (int i = 0; i &lt; citations.length; i++) {
            if (citations[citations.length - i - 1] &gt; i) {
                res++;
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="h-index-ii">H-Index II</h2>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.<br>
<a href="https://leetcode.com/problems/h-index-ii/description/">275. H-Index II</a></p>
<pre><code class="language-java">class Solution {
    public int hIndex(int[] citations) {
        int res = 0;
        for (int i = 0; i &lt; citations.length; i++) {
            if (citations[citations.length - i - 1] &gt; i) {
                res++;
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="shortest-word-distance">Shortest Word Distance</h2>
<p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>Example:</p>
<pre><code>Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;].

Input: word1 = “coding”, word2 = “practice”
Output: 3
Input: word1 = &quot;makes&quot;, word2 = &quot;coding&quot;
Output: 1
</code></pre>
<p>Note:<br>
You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.<br>
<a href="https://leetcode.com/problems/shortest-word-distance/">243. Shortest Word Distance</a></p>
<pre><code class="language-java">class Solution {
    public int shortestDistance(String[] words, String word1, String word2) {
        int res = Integer.MAX_VALUE;
        int count1 = -1, count2 = -1;
        for (int i = 0; i &lt; words.length; i++) {
            if (words[i].equals(word1)) {
                count1 = i;
                if (count2 != -1) {
                    res = Math.min(count1 - count2, res);
                }
            }
            if (words[i].equals(word2)) {
                count2 = i;
                if (count1 != -1) {
                    res = Math.min(count2 - count1, res);
                }
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="shortest-word-distance-ii">Shortest Word Distance II</h2>
<p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. Your method will be called repeatedly many times with different parameters.</p>
<p>Example:</p>
<pre><code>Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;].

Input: word1 = “coding”, word2 = “practice”
Output: 3
Input: word1 = &quot;makes&quot;, word2 = &quot;coding&quot;
Output: 1
</code></pre>
<p>Note:<br>
You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.<br>
<a href="https://leetcode.com/problems/shortest-word-distance-ii/description/"> 244. Shortest Word Distance II </a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="shortest-word-distance-iii">Shortest Word Distance III</h2>
<p>** ! **<br>
Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>word1 and word2 may be the same and they represent two individual words in the list.</p>
<p>Example:</p>
<pre><code>Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;].

Input: word1 = “makes”, word2 = “coding”
Output: 1
Input: word1 = &quot;makes&quot;, word2 = &quot;makes&quot;
Output: 3
</code></pre>
<p>Note:<br>
You may assume word1 and word2 are both in the list.</p>
<p><a href="https://leetcode.com/problems/shortest-word-distance-iii/"> 245. Shortest Word Distance III </a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="contains-duplicate">Contains Duplicate</h2>
<p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.<br>
Example:</p>
<pre><code>Example 1:

Input: [1,2,3,1]
Output: true
Example 2:

Input: [1,2,3,4]
Output: false
Example 3:

Input: [1,1,1,3,3,4,3,2,4,2]
Output: true
</code></pre>
<p><a href="https://leetcode.com/problems/contains-duplicate/"> Contains Duplicate </a></p>
<pre><code class="language-java">class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            if (set.contains(nums[i])) {
                return true;
            } else {
                set.add(nums[i]);
            }
        }
        return false;
    }
}
</code></pre>
<h2 id="contains-duplicate-ii">Contains Duplicate II</h2>
<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>Example:</p>
<pre><code>Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false
</code></pre>
<p><a href="https://leetcode.com/problems/contains-duplicate-ii/description/"> 219. Contains Duplicate II </a></p>
<pre><code class="language-java">class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            if (set.contains(nums[i])) {
                return true;
            } else {
                set.add(nums[i]);
            }
            if (i &gt;= k) {
                set.remove(nums[i - k]);
            }
        }
        return false;
    }
}
</code></pre>
<h2 id="contains-duplicate-ii-2">Contains Duplicate II</h2>
<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>Example:</p>
<pre><code>Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false
</code></pre>
<p><a href="https://leetcode.com/problems/contains-duplicate-ii/"> 219. Contains Duplicate II </a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="contains-duplicate-iii">Contains Duplicate III</h2>
<p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>
<p>Example:</p>
<pre><code>Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false
</code></pre>
<p><a href="https://leetcode.com/problems/contains-duplicate-iii/"> 219. Contains Duplicate III </a></p>
<pre><code class="language-java">
</code></pre>
<h2 id="jump-game">Jump Game</h2>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.<br>
Example:</p>
<pre><code>Example 1:

Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
</code></pre>
<p><a href="">  </a></p>
<pre><code class="language-java">class Solution {
    public boolean canJump(int[] nums) {
        int max = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (i &gt; max) {
                return false;
            }
            max = Math.max(max, i + nums[i]);
        }
        return true;
        
    }
}
</code></pre>
<h2 id="jump-game-ii">Jump Game II</h2>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.<br>
Example:</p>
<pre><code>Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.
</code></pre>
<p>Note:</p>
<p>You can assume that you can always reach the last index.<br>
<a href="https://leetcode.com/problems/jump-game-ii/"> 45. Jump Game II </a></p>
<pre><code class="language-java">
</code></pre>
<h2 id=""></h2>
<p>Example:</p>
<pre><code>
</code></pre>
<p><a href="">  </a></p>
<pre><code class="language-java">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode目录页面]]></title>
        <id>https://jiannanh.github.io/post/leetcode-mu-lu-ye-mian/</id>
        <link href="https://jiannanh.github.io/post/leetcode-mu-lu-ye-mian/">
        </link>
        <updated>2020-08-12T08:21:41.000Z</updated>
        <content type="html"><![CDATA[<p>跳转到相应的专题<br>
大类 小类 难度<br>
<a href="">Array</a><br>
String<br>
Math<br>
Tree<br>
Backtracking<br>
Dynamic Programming<br>
LinkedList<br>
Binary Search<br>
Matrix<br>
DFS &amp; BFS<br>
Stack &amp; PriorityQueue<br>
Bit Manipulation<br>
Topological Sort<br>
Random<br>
Graph<br>
Union Find<br>
Trie<br>
Design</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gRPC简介]]></title>
        <id>https://jiannanh.github.io/post/rpc/</id>
        <link href="https://jiannanh.github.io/post/rpc/">
        </link>
        <updated>2020-08-11T02:23:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="grpc简介">gRPC简介</h1>
<p><a href="https://grpc.io/docs/what-is-grpc/introduction/">gRPC简介</a><br>
想看官方的点上面这个链接，下面是我的翻译，方便大家观看</p>
<h1 id="grpc简介-我的翻译">gRPC简介 - 我的翻译</h1>
<p><strong>gRPC和协议缓冲区（protocol buffers）简介</strong><br>
该页面向您介绍gRPC和协议缓冲区。gRPC可以将protocol buffers用作其接口定义语言（IDL）和其消息交换格式。如果您不熟悉gRPC和/或protocol buffers，请阅读本章！如果您只是想深入了解gRPC的实际效果，请参阅<a href="https://grpc.io/docs/quickstart/">“ 快速入门”</a>。</p>
<h2 id="总览"><a href="#%E6%80%BB%E8%A7%88">总览</a></h2>
<p>在gRPC中，客户端应用程序可以直接在其他计算机上的服务器应用程序上调用方法，就好像它是本地对象一样，从而使您更轻松地创建分布式应用程序和服务。与许多RPC系统一样，gRPC围绕定义服​​务的思想，指定可通过其参数和返回类型远程调用的方法。在服务器端server（也有叫做 skeleton），服务器实现此接口并运行gRPC服务器以处理客户端调用。在客户端，客户端具有一个stub（也有称为 client ），提供与服务器相同的方法（可以看成在此保存后端的方法method）。<br>
<img src="https://jiannanh.github.io/post-images/1597303537698.svg" alt="" loading="lazy"><br>
从Google内部的服务器到您自己的台式机，gRPC客户端和服务器可以在各种环境中运行并相互通信，并且可以使用gRPC支持的任何语言编写。因此，例如，您可以使用Go，Python或Ruby的客户端轻松地用Java创建gRPC服务器。此外，最新的Google API将具有gRPC版本，可让您轻松地在应用程序中内置Google功能。</p>
<h2 id="使用协议缓冲区protocol-buffer"><a href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%86%B2%E5%8C%BAprotocol-buffer">使用协议缓冲区Protocol Buffer</a></h2>
<p>默认情况下，gRPC使用 <a href="https://developers.google.com/protocol-buffers/docs/overview">协议缓冲区 protocol buffers</a>，这是Google成熟的用于序列化结构化数据的开源机制（尽管它可以与其他数据格式（例如JSON）一起使用）。下面的部分是它的工作原理的快速介绍。如果您已经熟悉协议缓冲区，请随时跳到下一部分。</p>
<p>使用协议缓冲区的第一步是为要在原始文件中序列化的数据定义结构：这是带有.proto扩展名的普通文本文件。协议缓冲区数据被构造为 消息 message，其中每个消息都是信息的逻辑记录，其中包含一系列称为字段的名称/值对。下面一个简单的例子：</p>
<pre><code class="language-js">message Person {
  string name = 1;
  int32 id = 2;
  bool has_ponycopter = 3;
}
</code></pre>
<p>然后，一旦指定了数据结构，就可以使用协议缓冲区编译器protoc从原型定义中以首选语言生成数据访问类。这些为每个字段（例如name()和）提供了简单的访问器set_name()，以及将整个结构序列化为原始字节或从原始字节中解析出整个结构的方法。因此，例如，如果您选择的语言是C ++，则在上面的示例中运行编译器将生成一个名为的类Person。然后，您可以在应用程序中使用此类来填充，序列化和检索Person协议缓冲区消息。</p>
<p>您可以在普通的原始文件中定义gRPC服务，并使用RPC方法参数和返回类型指定为协议缓冲区消息：</p>
<pre><code class="language-js">// The greeter service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre>
<h2 id="protocol-buffer版本"><a href="#protocol-buffer%E7%89%88%E6%9C%AC">Protocol Buffer版本</a></h2>
<p>通常，虽然您可以使用proto2（当前的默认协议缓冲区版本），但建议您将proto3与gRPC一起使用，因为它可以使用gRPC支持的所有语言，并且可以避免与proto2客户端通信时出现的兼容性问题。 proto3服务器，反之亦然。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库面试]]></title>
        <id>https://jiannanh.github.io/post/shu-ju-ku-mian-shi/</id>
        <link href="https://jiannanh.github.io/post/shu-ju-ku-mian-shi/">
        </link>
        <updated>2020-08-10T07:36:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>https://blog.csdn.net/ThinkWon/article/details/104778621</p>
<p><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络 - 网络层]]></title>
        <id>https://jiannanh.github.io/post/ji-suan-ji-wang-luo-wang-luo-ceng/</id>
        <link href="https://jiannanh.github.io/post/ji-suan-ji-wang-luo-wang-luo-ceng/">
        </link>
        <updated>2020-08-09T11:20:00.000Z</updated>
        <content type="html"><![CDATA[<p>IP<br>
主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。<br>
功能1：路由选择与分组转发最佳路径<br>
功能2：实现异构网络的互联<br>
功能3：拥塞控制</p>
<h2 id="数据交换方式">数据交换方式</h2>
<p>多路复用</p>
<h3 id="报文交换">报文交换</h3>
<p>优点：</p>
<ol>
<li>无需建立连接</li>
<li>存储转发动态分配线路</li>
<li>线路可靠性高</li>
<li>线路利用率较高</li>
<li>多目标服务</li>
</ol>
<p>缺点：</p>
<ol>
<li>有存储时延</li>
<li>报文大小不确定，需要网络罗节点偶较大的存储空间。</li>
</ol>
<h3 id="分组交换">分组交换</h3>
<ol>
<li>无需建立连接</li>
<li>存储转发，动态分贝线路</li>
<li>线路可靠性较高</li>
<li>线路利用率较高</li>
<li>有利与报文交换，存储管理容易</li>
</ol>
<p>缺点：</p>
<ol>
<li>有存储时延</li>
<li>需要额外的信息量</li>
<li>乱序到目的主机时，要对分组排序重组</li>
</ol>
<h2 id="几种传输单元名词辨析">几种传输单元名词辨析</h2>
<figure data-type="image" tabindex="1"><img src="https://jiannanh.github.io/post-images/1596973848020.png" alt="" loading="lazy"></figure>
<h3 id="数据报">数据报</h3>
<p>无连接：不是先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p>
<h2 id="路由算法和路由协议">路由算法和路由协议</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络 - 1.3TCP/IP模型]]></title>
        <id>https://jiannanh.github.io/post/ji-suan-ji-wang-luo-tcpip-mo-xing/</id>
        <link href="https://jiannanh.github.io/post/ji-suan-ji-wang-luo-tcpip-mo-xing/">
        </link>
        <updated>2020-08-09T08:17:18.000Z</updated>
        <content type="html"><![CDATA[<p>TCP/IP是实时模型<br>
TCP/IP是先实践在生成的模型<br>
<img src="https://jiannanh.github.io/post-images/1596961494042.png" alt="" loading="lazy"><br>
<img src="https://jiannanh.github.io/post-images/1596964775219.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络 - 1.2OSI分层]]></title>
        <id>https://jiannanh.github.io/post/ji-suan-ji-wang-luo-osi-fen-ceng/</id>
        <link href="https://jiannanh.github.io/post/ji-suan-ji-wang-luo-osi-fen-ceng/">
        </link>
        <updated>2020-08-09T06:33:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="osi-分层">OSI 分层</h2>
<p>7层OSI法定标准<br>
物理层 - 数据链路层 - 网络层 - 传输层 - 会话层- 表示层 - 应用层<br>
通信子网 -           - 资源子网<br>
物联网输会示用</p>
<p>5层体系结构，方便学习。<br>
4层事实模型</p>
<ol>
<li>
<p>应用层<br>
需要上网才能使用的程序</p>
</li>
<li>
<p>表示层<br>
处理两个通讯徐通中光交换信息的表示方式<br>
功能1：数据格式变换<br>
功能2：数据加密解密<br>
功能3：数据压缩和恢复</p>
</li>
<li>
<p>会话层<br>
建立连接并在连接上有序地传输数据。这就是会话也是建立同步（SYN）。<br>
功能1：建立、管理、终止会话<br>
功能2：使用校验点可是会话在通讯失效时从校验点、同步点继续灰度通讯，实现数据同步。</p>
</li>
<li>
<p>传输层<br>
负责主机中两个进程的通信，即端到端的通信。传输单位是保温段或用户数据报。<br>
1：可靠传输、不可靠传输<br>
2：差错控制<br>
3：流量控制<br>
4：复用分用</p>
</li>
<li>
<p>网络层<br>
主要任务是把分组从远端传到目的端，为分组交换网上的不同主机提供通信服务网络层传输单位是数据拥报。<br>
功能1：路由选择<br>
功能2：流量选择<br>
功能3：差错控制<br>
功能4：拥塞控制</p>
</li>
<li>
<p>数据链路层<br>
把网络层传下来的数据报组装成帧<br>
数据链路层/链路层的传输单位是帧。<br>
功能1：成帧<br>
功能2：差错控制<br>
功能3：流量控制<br>
功能4：访问（接入）控制</p>
</li>
<li>
<p>物理层<br>
主要任务是在物理媒体上实现比特流的透明传输。<br>
物理层传输单位是比特<br>
功能1：定义接口特性<br>
功能2：定义传输模式<br>
功能3：定义传输速率<br>
功能4：比特同步<br>
功能4：比特编码</p>
</li>
</ol>
]]></content>
    </entry>
</feed>