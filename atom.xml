<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiannanh.github.io</id>
    <title>Gridea</title>
    <updated>2020-08-19T03:26:09.492Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiannanh.github.io"/>
    <link rel="self" href="https://jiannanh.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiannanh.github.io/images/avatar.png</logo>
    <icon>https://jiannanh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[gRPC-web]]></title>
        <id>https://jiannanh.github.io/post/cong-ling-kai-shi-grpc/</id>
        <link href="https://jiannanh.github.io/post/cong-ling-kai-shi-grpc/">
        </link>
        <updated>2020-08-17T12:27:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rpc-是什么">RPC 是什么？</h1>
<h2 id="1-rpc是什么">1. RPC是什么</h2>
<blockquote>
<p>在分布式计算中，远程过程调用（RPC）是指计算机程序使过程（子例程）在不同的地址空间（通常在共享网络的另一台计算机上）执行时，远程的过程就像是普通的（本地）调用，而无需程序员为远程过程写过多的代码。即，无论子例程是正在执行的程序是本地程序还是远程程序，程序员都编写基本相同的代码。这是客户端-服务器交互的一种形式（客户端调用，服务器执行），通常是通过请求-响应消息传递系统来实现的。在面向对象的编程语言（JAVA）中，RPC由远程方法调用表示（RMI）。RPC模型意味着一定程度的位置透明性，即无论本地还是远程，调用过程在很大程度上是相同的，但是实质上它们并不相同，（感受上很像是在本地，但是实际上是在远程调用）因此可以将本地调用与远程调用区分开。<br>
远程呼叫通常比本地呼叫慢几个数量级，并且可靠性较差，因此区分它们很重要。（但是实际应用中，前后端是分离的，这样的比较对rpc来说并不公平）<br>
wiki 要记得修饰一下。<a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call</a></p>
</blockquote>
<p>从上面的 Wiki 中可以看出 RPC 更多像是一种概念。目前，RPC 这种概念已经被许多不同的（通常是不兼容的）技术已被用来实现。包括gRPC。</p>
<h3 id="为什么选择grpc-web">为什么选择gRPC-web？</h3>
<p>gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过插件来支持有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后步骤，以将设备，移动应用程序和浏览器连接到后端服务。</p>
<p>到目前为止，这些好处基本上仅适用于移动应用程序和后端开发人员，而前端开发人员则不得不继续依赖JSON REST接口作为其主要的信息交换手段。但是，随着gRPC-Web的发布，gRPC有望成为前端开发人员工具箱中的宝贵补充。<a href="https://grpc.io/blog/state-of-grpc-web/">link</a></p>
<p>在我看来，gRPC-Web的优点在于，它使您能够从Web客户端一直创建完整的端到端gRPC服务体系结构。以前，如果您想将gRPC驱动的后端与Web客户端结合使用，则需要编写REST API逻辑来与gRPC进行HTTP调用之间的转换-我们大多数人都愿意避免的工作。gRPC-Web使您能够直接使用协议缓冲区封装所有数据接口，从而使您不必再编写其他HTTP服务器。<a href="https://blog.envoyproxy.io/envoy-and-grpc-web-a-fresh-new-alternative-to-rest-6504ce7eb880">link</a></p>
<p>还将获得使用协议缓冲区的所有优点，包括高效的序列化，简单的IDL和轻松的接口更新。gRPC-Web使您可以使用惯用的API从浏览器访问以这种方式构建的gRPC服务。</p>
<pre><code>使用gRPC，您可以在.proto文件中一次定义服务，并以gRPC支持的任何语言来实现客户端和服务器，而这些语言又可以在从大型数据中心内的服务器到您自己的平板电脑的环境中运行-这一切的复杂性gRPC为您处理不同语言和环境之间的通信。您还将获得使用协议缓冲区的所有优点，包括高效的序列化，简单的IDL和轻松的接口更新。gRPC-Web使您可以使用惯用的API从浏览器访问以这种方式构建的gRPC服务。
</code></pre>
<h3 id="grpc的四个优点">gRPC的四个优点</h3>
<ol>
<li>简单的服务定义<br>
使用 Protocol Buffer 这种强大的二进制序列化工具来定义服务。</li>
<li>快速启动和扩展<br>
只需要一行命令即可安装运行时和开发环境。此外，使用此框架每秒可以扩展数百万个 RPC</li>
<li>跨语言和平台工作<br>
用你惯用的语言自动地生成client和service</li>
<li>双向流和集成身份验证<br>
以HTTP/2为基础的双向流和插件化认证</li>
</ol>
<h2 id="2-restful-和-rpc-这一块最后讲">2. Restful 和 RPC 这一块最后讲</h2>
<p>RPC是面向过程，RESTful 是面向资源也就是 url，并且使用了 HTTP 操作。从这个维度上看，RESTful风格的 url 在表述的精简性、可读性上都要更好。</p>
<p>其他的诸如，协议版本，RPC 中的代理序列化等差异。我个人觉得只是实现上的区别。</p>
<h2 id="为什么要用-rpc-grpc-web">为什么要用 RPC || gRPC-web</h2>
<p>最开始应用都是单体的应用，开发比较简单，但程序部署比较麻烦。如果有一个环节出了问题，也可以比较快的横向扩展。大的应用之间的通信需要使用rpc进行通信。</p>
<p>无感知调用<br>
RPC 可以定制化，可以减少传输过程之中的一些损耗。<br>
RPC 基于的协议可能是 TCP 或者 UDP 让网络传输更快。</p>
<p>开发模式的提升，就像是前后端分离的理念细化了分工，提升了效率和代码质量。gRPC-web （或许）能节约对接口的复杂过程。对接多个不同语言代码的后端。所有的语言共一个接口写法。</p>
<h2 id="rpc-模块-如何搭建一个-rpc">RPC 模块 - 如何搭建一个 RPC</h2>
<p>通信经过网络，传统的单体应用要通过接口。远程的方法是如何使用的。我也可以把远程的方法变成接口。通过代理技术。在调用的过程中，对方法进行拦截，对参数进行序列化。在序列化的过程中，拿到目标地址。编解码后，传到网络上。目标地址监听网络，拿到数据包进行解码，拿到二进制数据进行反序列化。通过反射执行。通过相反的路传回给调用方。调用方获得结果。<br>
<img src="https://jiannanh.github.io/post-images/1597113191937.png" alt="" loading="lazy"></p>
<h2 id="rpc架构">RPC架构</h2>
<figure data-type="image" tabindex="1"><img src="https://jiannanh.github.io/post-images/1597113273813.png" alt="" loading="lazy"></figure>
<h2 id="quick-start">Quick start</h2>
<p>谈了这么多的 RPC-web 的好处，接下来有两个小 case可以快速的感受 RPC-web 的实际效果。<br>
首先是 gRPC-web 的<a href="https://grpc.io/docs/languages/web/quickstart/">官方demo</a>这个demo 跑起来很方便，但是整个 demo 和 gRPC-web 的其他文件放在了一起，RPC-web 的主要功能反而不好发现。</p>
<p>第二个是一个，React gRPC-web 的 demo，这个项目比较简单，也能更好的体会到核心的几个功能模块。比如 protoc，protoc-web，envoy代理，和 docker 等。<br>
<img src="https://jiannanh.github.io/post-images/1597807417559.jpeg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode目录页面]]></title>
        <id>https://jiannanh.github.io/post/leetcode-mu-lu-ye-mian/</id>
        <link href="https://jiannanh.github.io/post/leetcode-mu-lu-ye-mian/">
        </link>
        <updated>2020-08-12T08:21:41.000Z</updated>
        <content type="html"><![CDATA[<p>跳转到相应的专题<br>
<a href="">Array</a><br>
String<br>
Math<br>
Tree<br>
Backtracking<br>
Dynamic Programming<br>
LinkedList<br>
Binary Search<br>
Matrix<br>
DFS &amp; BFS<br>
Stack &amp; PriorityQueue<br>
Bit Manipulation<br>
Topological Sort<br>
Random<br>
Graph<br>
Union Find<br>
Trie<br>
Design</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gRPC简介]]></title>
        <id>https://jiannanh.github.io/post/rpc/</id>
        <link href="https://jiannanh.github.io/post/rpc/">
        </link>
        <updated>2020-08-11T02:23:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="grpc简介">gRPC简介</h1>
<p><a href="https://grpc.io/docs/what-is-grpc/introduction/">gRPC简介</a><br>
想看官方的点上面这个链接，下面是我的翻译，方便大家观看</p>
<h1 id="grpc简介-我的翻译">gRPC简介 - 我的翻译</h1>
<p><strong>gRPC和协议缓冲区（protocol buffers）简介</strong><br>
该页面向您介绍gRPC和协议缓冲区。gRPC可以将protocol buffers用作其接口定义语言（IDL）和其消息交换格式。如果您不熟悉gRPC和/或protocol buffers，请阅读本章！如果您只是想深入了解gRPC的实际效果，请参阅<a href="https://grpc.io/docs/quickstart/">“ 快速入门”</a>。</p>
<h2 id="总览"><a href="#%E6%80%BB%E8%A7%88">总览</a></h2>
<p>在gRPC中，客户端应用程序可以直接在其他计算机上的服务器应用程序上调用方法，就好像它是本地对象一样，从而使您更轻松地创建分布式应用程序和服务。与许多RPC系统一样，gRPC围绕定义服​​务的思想，指定可通过其参数和返回类型远程调用的方法。在服务器端server（也有叫做 skeleton），服务器实现此接口并运行gRPC服务器以处理客户端调用。在客户端，客户端具有一个stub（也有称为 client ），提供与服务器相同的方法（可以看成在此保存后端的方法method）。<br>
<img src="https://jiannanh.github.io/post-images/1597303537698.svg" alt="" loading="lazy"><br>
从Google内部的服务器到您自己的台式机，gRPC客户端和服务器可以在各种环境中运行并相互通信，并且可以使用gRPC支持的任何语言编写。因此，例如，您可以使用Go，Python或Ruby的客户端轻松地用Java创建gRPC服务器。此外，最新的Google API将具有gRPC版本，可让您轻松地在应用程序中内置Google功能。</p>
<h2 id="使用协议缓冲区protocol-buffer"><a href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%86%B2%E5%8C%BAprotocol-buffer">使用协议缓冲区Protocol Buffer</a></h2>
<p>默认情况下，gRPC使用 <a href="https://developers.google.com/protocol-buffers/docs/overview">协议缓冲区 protocol buffers</a>，这是Google成熟的用于序列化结构化数据的开源机制（尽管它可以与其他数据格式（例如JSON）一起使用）。下面的部分是它的工作原理的快速介绍。如果您已经熟悉协议缓冲区，请随时跳到下一部分。</p>
<p>使用协议缓冲区的第一步是为要在原始文件中序列化的数据定义结构：这是带有.proto扩展名的普通文本文件。协议缓冲区数据被构造为 消息 message，其中每个消息都是信息的逻辑记录，其中包含一系列称为字段的名称/值对。下面一个简单的例子：</p>
<pre><code class="language-js">message Person {
  string name = 1;
  int32 id = 2;
  bool has_ponycopter = 3;
}
</code></pre>
<p>然后，一旦指定了数据结构，就可以使用协议缓冲区编译器protoc从原型定义中以首选语言生成数据访问类。这些为每个字段（例如name()和）提供了简单的访问器set_name()，以及将整个结构序列化为原始字节或从原始字节中解析出整个结构的方法。因此，例如，如果您选择的语言是C ++，则在上面的示例中运行编译器将生成一个名为的类Person。然后，您可以在应用程序中使用此类来填充，序列化和检索Person协议缓冲区消息。</p>
<p>您可以在普通的原始文件中定义gRPC服务，并使用RPC方法参数和返回类型指定为协议缓冲区消息：</p>
<pre><code class="language-js">// The greeter service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre>
<h2 id="protocol-buffer版本"><a href="#protocol-buffer%E7%89%88%E6%9C%AC">Protocol Buffer版本</a></h2>
<p>通常，虽然您可以使用proto2（当前的默认协议缓冲区版本），但建议您将proto3与gRPC一起使用，因为它可以使用gRPC支持的所有语言，并且可以避免与proto2客户端通信时出现的兼容性问题。 proto3服务器，反之亦然。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库面试]]></title>
        <id>https://jiannanh.github.io/post/shu-ju-ku-mian-shi/</id>
        <link href="https://jiannanh.github.io/post/shu-ju-ku-mian-shi/">
        </link>
        <updated>2020-08-10T07:36:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>https://blog.csdn.net/ThinkWon/article/details/104778621</p>
<p><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络 - 网络层]]></title>
        <id>https://jiannanh.github.io/post/ji-suan-ji-wang-luo-wang-luo-ceng/</id>
        <link href="https://jiannanh.github.io/post/ji-suan-ji-wang-luo-wang-luo-ceng/">
        </link>
        <updated>2020-08-09T11:20:00.000Z</updated>
        <content type="html"><![CDATA[<p>IP<br>
主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。<br>
功能1：路由选择与分组转发最佳路径<br>
功能2：实现异构网络的互联<br>
功能3：拥塞控制</p>
<h2 id="数据交换方式">数据交换方式</h2>
<p>多路复用</p>
<h3 id="报文交换">报文交换</h3>
<p>优点：</p>
<ol>
<li>无需建立连接</li>
<li>存储转发动态分配线路</li>
<li>线路可靠性高</li>
<li>线路利用率较高</li>
<li>多目标服务</li>
</ol>
<p>缺点：</p>
<ol>
<li>有存储时延</li>
<li>报文大小不确定，需要网络罗节点偶较大的存储空间。</li>
</ol>
<h3 id="分组交换">分组交换</h3>
<ol>
<li>无需建立连接</li>
<li>存储转发，动态分贝线路</li>
<li>线路可靠性较高</li>
<li>线路利用率较高</li>
<li>有利与报文交换，存储管理容易</li>
</ol>
<p>缺点：</p>
<ol>
<li>有存储时延</li>
<li>需要额外的信息量</li>
<li>乱序到目的主机时，要对分组排序重组</li>
</ol>
<h2 id="几种传输单元名词辨析">几种传输单元名词辨析</h2>
<figure data-type="image" tabindex="1"><img src="https://jiannanh.github.io/post-images/1596973848020.png" alt="" loading="lazy"></figure>
<h3 id="数据报">数据报</h3>
<p>无连接：不是先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p>
<h2 id="路由算法和路由协议">路由算法和路由协议</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络 - 1.3TCP/IP模型]]></title>
        <id>https://jiannanh.github.io/post/ji-suan-ji-wang-luo-tcpip-mo-xing/</id>
        <link href="https://jiannanh.github.io/post/ji-suan-ji-wang-luo-tcpip-mo-xing/">
        </link>
        <updated>2020-08-09T08:17:18.000Z</updated>
        <content type="html"><![CDATA[<p>TCP/IP是实时模型<br>
TCP/IP是先实践在生成的模型<br>
<img src="https://jiannanh.github.io/post-images/1596961494042.png" alt="" loading="lazy"><br>
<img src="https://jiannanh.github.io/post-images/1596964775219.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络 - 1.2OSI分层]]></title>
        <id>https://jiannanh.github.io/post/ji-suan-ji-wang-luo-osi-fen-ceng/</id>
        <link href="https://jiannanh.github.io/post/ji-suan-ji-wang-luo-osi-fen-ceng/">
        </link>
        <updated>2020-08-09T06:33:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="osi-分层">OSI 分层</h2>
<p>7层OSI法定标准<br>
物理层 - 数据链路层 - 网络层 - 传输层 - 会话层- 表示层 - 应用层<br>
通信子网 -           - 资源子网<br>
物联网输会示用</p>
<p>5层体系结构，方便学习。<br>
4层事实模型</p>
<ol>
<li>
<p>应用层<br>
需要上网才能使用的程序</p>
</li>
<li>
<p>表示层<br>
处理两个通讯徐通中光交换信息的表示方式<br>
功能1：数据格式变换<br>
功能2：数据加密解密<br>
功能3：数据压缩和恢复</p>
</li>
<li>
<p>会话层<br>
建立连接并在连接上有序地传输数据。这就是会话也是建立同步（SYN）。<br>
功能1：建立、管理、终止会话<br>
功能2：使用校验点可是会话在通讯失效时从校验点、同步点继续灰度通讯，实现数据同步。</p>
</li>
<li>
<p>传输层<br>
负责主机中两个进程的通信，即端到端的通信。传输单位是保温段或用户数据报。<br>
1：可靠传输、不可靠传输<br>
2：差错控制<br>
3：流量控制<br>
4：复用分用</p>
</li>
<li>
<p>网络层<br>
主要任务是把分组从远端传到目的端，为分组交换网上的不同主机提供通信服务网络层传输单位是数据拥报。<br>
功能1：路由选择<br>
功能2：流量选择<br>
功能3：差错控制<br>
功能4：拥塞控制</p>
</li>
<li>
<p>数据链路层<br>
把网络层传下来的数据报组装成帧<br>
数据链路层/链路层的传输单位是帧。<br>
功能1：成帧<br>
功能2：差错控制<br>
功能3：流量控制<br>
功能4：访问（接入）控制</p>
</li>
<li>
<p>物理层<br>
主要任务是在物理媒体上实现比特流的透明传输。<br>
物理层传输单位是比特<br>
功能1：定义接口特性<br>
功能2：定义传输模式<br>
功能3：定义传输速率<br>
功能4：比特同步<br>
功能4：比特编码</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络 - 1.1速率相关性能指标]]></title>
        <id>https://jiannanh.github.io/post/ji-suan-ji-wang-luo-su-lu-xiang-guan-xing-neng-zhi-biao/</id>
        <link href="https://jiannanh.github.io/post/ji-suan-ji-wang-luo-su-lu-xiang-guan-xing-neng-zhi-biao/">
        </link>
        <updated>2020-08-09T05:37:39.000Z</updated>
        <content type="html"><![CDATA[<p>塑料布及数据率或称数据传输率或比特率，<br>
比特 1 / 0<br>
链接在计算机网络上的主机在数字通道上传送数据的速率。<br>
1 byte = 8 bite</p>
<h2 id="带宽">带宽</h2>
<ol>
<li><strong>带宽</strong>原本值莫格信号具有的频带宽度，即最高频率与最低频率之差，单位是 Hz。</li>
<li>计算机网络中，<strong>带宽</strong>用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络 中的抹一点到零一点所能通过的 <font  color="red">最高数据率</font >。 单位是 ”比特每秒“，b/s，kb/s 。。、<br>
是网络设备所支持的最高速率</li>
</ol>
<h2 id="吞吐量">吞吐量</h2>
<p>单位时间内通过某个网络（或信道、接口）的数据量，单位是b/s，kb/s<br>
吞吐量收网络的带宽或者网络的额定速率的限制。</p>
<h2 id="时延">时延</h2>
<p>是数据（报文、分组、比特流）从网络（链路）的一端传送到另一端所需要的事件。也叫延迟或者迟延。单位是 s。<br>
时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延</p>
<ol>
<li>
<p>发送时延<br>
从发送分组的第一个比特算起到该分组的最后一个比特发送所需要的时间。<br>
发送时延 = 数据长度 / 信道带宽</p>
</li>
<li>
<p>传播时延<br>
电磁波的传播速度和链路长度<br>
传播时延 = 链路长度 / 电磁波的传播速度</p>
</li>
<li>
<p>排队时延<br>
在路由器等待输入和输出的时间</p>
</li>
<li>
<p>处理时延<br>
检查找出口，路由器检查错误，并且决定从那个端口输出。</p>
</li>
<li>
<p>往返时延 RTT<br>
从发送方开始发送数据开始，到发送当接收到接收方是确认，总共时延。</p>
</li>
</ol>
]]></content>
    </entry>
</feed>