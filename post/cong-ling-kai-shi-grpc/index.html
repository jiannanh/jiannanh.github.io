<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>gRPC-web | Jiannan</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://jiannanh.github.io/favicon.ico?v=1597809975893">
<link rel="stylesheet" href="https://jiannanh.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="RPC 是什么？
1. RPC是什么

在分布式计算中，远程过程调用（RPC）是指计算机程序使过程（子例程）在不同的地址空间（通常在共享网络的另一台计算机上）执行时，远程的过程就像是普通的（本地）调用，而无需程序员为远程过程写过多的代码。即..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://jiannanh.github.io">
        <img src="https://jiannanh.github.io/images/avatar.png?v=1597809975893" class="site-logo">
        <h1 class="site-title">Jiannan</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://jiannanh.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">gRPC-web</h2>
            <div class="post-date">2020-08-17</div>
            
              <div class="feature-container" style="background-image: url('https://jiannanh.github.io/post-images/cong-ling-kai-shi-grpc.png')">
              </div>
            
            <div class="post-content" v-pre>
              <h1 id="rpc-是什么">RPC 是什么？</h1>
<h2 id="1-rpc是什么">1. RPC是什么</h2>
<blockquote>
<p>在分布式计算中，远程过程调用（RPC）是指计算机程序使过程（子例程）在不同的地址空间（通常在共享网络的另一台计算机上）执行时，远程的过程就像是普通的（本地）调用，而无需程序员为远程过程写过多的代码。即，无论子例程是正在执行的程序是本地程序还是远程程序，程序员都编写基本相同的代码。这是客户端-服务器交互的一种形式（客户端调用，服务器执行），通常是通过请求-响应消息传递系统来实现的。在面向对象的编程语言（JAVA）中，RPC由远程方法调用表示（RMI）。RPC模型意味着一定程度的位置透明性，即无论本地还是远程，调用过程在很大程度上是相同的，但是实质上它们并不相同，（感受上很像是在本地，但是实际上是在远程调用）因此可以将本地调用与远程调用区分开。<br>
远程呼叫通常比本地呼叫慢几个数量级，并且可靠性较差，因此区分它们很重要。（但是实际应用中，前后端是分离的，这样的比较对rpc来说并不公平）<br>
wiki 要记得修饰一下。<a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call</a></p>
</blockquote>
<p>从上面的 Wiki 中可以看出 RPC 更多像是一种概念。目前，RPC 这种概念已经被许多不同的（通常是不兼容的）技术已被用来实现。包括gRPC。</p>
<h3 id="为什么选择grpc-web">为什么选择gRPC-web？</h3>
<p>gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过插件来支持有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后步骤，以将设备，移动应用程序和浏览器连接到后端服务。</p>
<p>到目前为止，这些好处基本上仅适用于移动应用程序和后端开发人员，而前端开发人员则不得不继续依赖JSON REST接口作为其主要的信息交换手段。但是，随着gRPC-Web的发布，gRPC有望成为前端开发人员工具箱中的宝贵补充。<a href="https://grpc.io/blog/state-of-grpc-web/">link</a></p>
<p>在我看来，gRPC-Web的优点在于，它使您能够从Web客户端一直创建完整的端到端gRPC服务体系结构。以前，如果您想将gRPC驱动的后端与Web客户端结合使用，则需要编写REST API逻辑来与gRPC进行HTTP调用之间的转换-我们大多数人都愿意避免的工作。gRPC-Web使您能够直接使用协议缓冲区封装所有数据接口，从而使您不必再编写其他HTTP服务器。<a href="https://blog.envoyproxy.io/envoy-and-grpc-web-a-fresh-new-alternative-to-rest-6504ce7eb880">link</a></p>
<p>还将获得使用协议缓冲区的所有优点，包括高效的序列化，简单的IDL和轻松的接口更新。gRPC-Web使您可以使用惯用的API从浏览器访问以这种方式构建的gRPC服务。</p>
<p>使用gRPC，您可以在.proto文件中一次定义服务，并以gRPC支持的任何语言来实现客户端和服务器，而这些语言又可以在从大型数据中心内的服务器到您自己的平板电脑的环境中运行-这一切的复杂性gRPC为您处理不同语言和环境之间的通信。您还将获得使用协议缓冲区的所有优点，包括高效的序列化，简单的IDL和轻松的接口更新。gRPC-Web使您可以使用惯用的API从浏览器访问以这种方式构建的gRPC服务。</p>
<h3 id="grpc的四个优点">gRPC的四个优点</h3>
<ol>
<li>简单的服务定义<br>
使用 Protocol Buffer 这种强大的二进制序列化工具来定义服务。</li>
<li>快速启动和扩展<br>
只需要一行命令即可安装运行时和开发环境。此外，使用此框架每秒可以扩展数百万个 RPC</li>
<li>跨语言和平台工作<br>
用你惯用的语言自动地生成client和service</li>
<li>双向流和集成身份验证<br>
以HTTP/2为基础的双向流和插件化认证</li>
</ol>
<h2 id="rpc-模块-如何搭建一个-rpc">RPC 模块 - 如何搭建一个 RPC</h2>
<p>通信经过网络，传统的单体应用要通过接口。远程的方法是如何使用的。我也可以把远程的方法变成接口。通过代理技术。在调用的过程中，对方法进行拦截，对参数进行序列化。在序列化的过程中，拿到目标地址。编解码后，传到网络上。目标地址监听网络，拿到数据包进行解码，拿到二进制数据进行反序列化。通过反射执行。通过相反的路传回给调用方。调用方获得结果。<br>
<img src="https://jiannanh.github.io/post-images/1597113191937.png" alt="" loading="lazy"></p>
<h2 id="rpc架构">RPC架构</h2>
<figure data-type="image" tabindex="1"><img src="https://jiannanh.github.io/post-images/1597113273813.png" alt="" loading="lazy"></figure>
<h2 id="grpc-web-架构">gRPC-web 架构</h2>
<p><img src="https://jiannanh.github.io/post-images/1597809413017.png" alt="" loading="lazy"><br>
<img src="https://jiannanh.github.io/post-images/1597809418373.png" alt="" loading="lazy"></p>
<h2 id="2-restful-和-rpc">2. Restful 和 RPC</h2>
<p>RPC是面向过程，RESTful 是面向资源也就是 url，并且使用了 HTTP 操作。从这个维度上看，RESTful风格的 url 在表述的精简性、可读性上都要更好。</p>
<p>其他的诸如，协议版本，RPC 中的代理序列化等差异。我个人觉得只是实现上的区别。</p>
<h2 id="为什么要用-rpc-grpc-web">为什么要用 RPC || gRPC-web</h2>
<p>最开始应用都是单体的应用，开发比较简单，但程序部署比较麻烦。如果有一个环节出了问题，也可以比较快的横向扩展。大的应用之间的通信需要使用rpc进行通信。</p>
<p>开发模式的提升，就像是前后端分离的理念细化了分工，提升了效率和代码质量。gRPC-web （或许）能节约对接口的复杂过程。对接多个不同语言代码的后端。所有的语言共一个接口写法。</p>
<h2 id="quick-start">Quick start</h2>
<p>谈了这么多的 RPC-web 的好处，接下来有两个小 case可以快速的感受 RPC-web 的实际效果。</p>
<p>首先是 gRPC-web 的<a href="https://grpc.io/docs/languages/web/quickstart/">官方demo</a>这个demo 跑起来很方便，但是整个 demo 和 gRPC-web 的其他文件放在了一起，RPC-web 的主要功能反而不好发现。</p>
<p>第二个是一个，React gRPC-web 的 demo，这个项目比较简单，也能更好的体会到核心的几个功能模块。比如 protoc，protoc-web，envoy代理，和 docker 等。<br>
<img src="https://jiannanh.github.io/post-images/1597807417559.jpeg" alt="" loading="lazy"></p>
<p>在开始之前，请确保已安装以下组件：</p>
<ol>
<li>npm (Node package manager) - For generating react project <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025597810528">download</a></li>
<li>Docker - For running envoy locally <a href="https://www.docker.com/get-started">download</a></li>
<li>protoc - For generating code using protos <a href="https://github.com/protocolbuffers/protobuf/releases">download</a><br>
protoc 的 exe 文件是下面这些。<strong>不要</strong>下载其他的文件。<br>
protoc-3.13.0-osx-x86_64.zip<br>
protoc-3.13.0-win64.zip</li>
<li>下载 protoc-gen-grpc-web 插件 <a href="https://github.com/grpc/grpc-web/releases">download</a></li>
</ol>
<p><strong>一定一定</strong>要记得把文件放到 PATH 中。<br>
MacOS, 可以这样:</p>
<pre><code>$ sudo mv ~/Downloads/protoc-gen-grpc-web-1.2.1-darwin-x86_64 \
    /usr/local/bin/protoc-gen-grpc-web
$ chmod +x /usr/local/bin/protoc-gen-grpc-web
</code></pre>
<p>1.用户界面-网站使用react<br>
为了创建一个React项目，我们将使用create-react-app命令。</p>
<p>create-react-app learn-react-grpc<br>
现在我们已经有了一个示例项目，让我们创建一个原型。这就是乒乓球的原型。</p>
<pre><code>syntax = &quot;proto3&quot;;

package pingpong;

message PingRequest {
    string ping = 1;
}

message PongResponse {
    string pong = 1;
}

service PingPongService {
    rpc pingPong(PingRequest) returns (PongResponse);
}
</code></pre>
<p>要运行后续命令，请确保原型位于react项目的src /文件夹中。要在javascript中生成客户端代码，请运行以下命令：</p>
<pre><code>protoc -I=. src/ping_pong.proto --js_out=import_style=commonjs:. --grpc-web_out=import_style=commonjs,mode=grpcwebtext:.
</code></pre>
<p>这将生成两个新文件：* ping_pong_pb.js *和ping_pong_grpc_web_pb.js，其中包含所有生成的代码。我们将使用此代码向我们的gRPC服务发出请求。</p>
<p>首先，让我们使用一些与gRPC和protobuf相关的依赖项更新package.json，然后运行npm install <em>。</em></p>
<pre><code class="language-json">{
      &quot;name&quot;: &quot;learn-react-grpc&quot;,
      &quot;version&quot;: &quot;0.1.0&quot;,
      &quot;private&quot;: true,
      &quot;dependencies&quot;: {
        &quot;react&quot;: &quot;^16.8.6&quot;,
        &quot;react-dom&quot;: &quot;^16.8.6&quot;,
        &quot;react-scripts&quot;: &quot;2.1.8&quot;,
        &quot;@grpc/grpc-js&quot;: &quot;^0.3.6&quot;,
        &quot;google-protobuf&quot;: &quot;^3.7.1&quot;,
        &quot;grpc&quot;: &quot;^1.19.0&quot;,
        &quot;grpc-web&quot;: &quot;^1.0.4&quot;
      },
      &quot;scripts&quot;: {
        &quot;start&quot;: &quot;react-scripts start&quot;,
        &quot;build&quot;: &quot;react-scripts build&quot;,
        &quot;test&quot;: &quot;react-scripts test&quot;,
        &quot;eject&quot;: &quot;react-scripts eject&quot;
      },
      &quot;eslintConfig&quot;: {
        &quot;extends&quot;: &quot;react-app&quot;
      },
      &quot;browserslist&quot;: [
        &quot;&gt;0.2%&quot;,
        &quot;not dead&quot;,
        &quot;not ie &lt;= 11&quot;,
        &quot;not op_mini all&quot;
      ]
    }
</code></pre>
<p>以下是构建我们的网站的全部逻辑。您可以在App.js文件中使用此代码。这是一个非常简单的网站，其中包含一个按钮，单击可创建一个乒乓球请求并获得响应。</p>
<pre><code class="language-js">import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';


const { PingPongServiceClient } = require('./ping_pong_grpc_web_pb');
const { PingRequest, PongResponse } = require('./ping_pong_pb.js');


var client = new PingPongServiceClient('http://localhost:9090', null, null);


class App extends Component {

  callGrpcService = () =&gt; {
    const request = new PingRequest();
    request.setPing('Ping');


    client.pingPong(request, {}, (err, response) =&gt; {
      if (response == null) {
        console.log(err)
      } else {
        console.log(response.getPong())
      }
    });
  }


  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;header className=&quot;App-header&quot;&gt;
          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;
          &lt;button style={{ padding: 10 }} onClick={this.callGrpcService}&gt;Click for grpc request&lt;/button&gt;
        &lt;/header&gt;
      &lt;/div&gt;
    );
  }
}

export default App;
</code></pre>
<p>现在，如果您使用npm start运行节点服务器，那么您很可能会遇到此编译问题。将gRPC-web与通过* create-react-app *命令行界面创建的项目一起使用时，这显然是一个问题。<br>
<img src="https://jiannanh.github.io/post-images/1597808817596.png" alt="" loading="lazy"></p>
<p>但是，可以通过向所有原型生成的文件添加eslint-disable *来解决此问题。确保对所有文件都执行此操作。现在，如果您启动服务器，一切都应该正常工作。</p>
<figure data-type="image" tabindex="2"><img src="https://jiannanh.github.io/post-images/1597808828467.png" alt="" loading="lazy"></figure>
<p>2.后端-Node中的gRPC服务器<br>
让我们创建一个简单的节点服务器。我们将使用与React应用中相同的原型。让我们创建一个节点js应用程序node-ping-pong-server。这是我们的示例server.js文件。</p>
<pre><code class="language-js">var grpc = require('grpc');
var pingPongProto = grpc.load('ping_pong.proto');
var server = new grpc.Server();


server.addService(pingPongProto.pingpong.PingPongService.service, {
  pingPong: function (call, callback) {
    console.log(&quot;Request&quot;)
    return callback(null, { pong: &quot;Pong&quot; })
  }
});


server.bind('localhost:8080', grpc.ServerCredentials.createInsecure());
server.start();
</code></pre>
<p>我们可以使用以下命令运行节点服务器：</p>
<pre><code class="language-js">node server.js
</code></pre>
<p>3.代理人-特使<br>
如上所述，我们将使用Docker来设置特使。这是docker文件。在撰写本文时，最新标签指向Envoy * 1.11版。*在您的应用程序的src /文件夹中创建一个Dockerfile。</p>
<pre><code class="language-docker">FROM envoyproxy/envoy-dev:latest

COPY ./envoy.yaml /etc/envoy/envoy.yaml

CMD /usr/local/bin/envoy -c /etc/envoy/envoy.yaml -l trace --log-path /tmp/envoy_info.log
</code></pre>
<p>在运行Docker容器之前，我们需要确保有一个用于envoy的配置文件。将此envoy.yml添加到react应用的src /文件夹中。</p>
<pre><code class="language-yaml">admin:
  access_log_path: /tmp/admin_access.log
  address:
    socket_address: { address: 0.0.0.0, port_value: 9901 }

static_resources:
  listeners:
  - name: listener_0
    address:
      socket_address: { address: 0.0.0.0, port_value: 9090 }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          &quot;@type&quot;: type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: local_service
              domains: [&quot;*&quot;]
              routes:
              - match: { prefix: &quot;/&quot; }
                route:
                  cluster: ping_pong_service
                  max_grpc_timeout: 0s
              cors:
                allow_origin_string_match:
                - prefix: &quot;*&quot;
                allow_methods: GET, PUT, DELETE, POST, OPTIONS
                allow_headers: keep-alive,user-agent,cache-control,content-type,content-transfer-encoding,custom-header-1,x-accept-content-transfer-encoding,x-accept-response-streaming,x-user-agent,x-grpc-web,grpc-timeout
                max_age: &quot;1728000&quot;
                expose_headers: custom-header-1,grpc-status,grpc-message
          http_filters:
          - name: envoy.filters.http.grpc_web
          - name: envoy.filters.http.cors
          - name: envoy.filters.http.router
  clusters:
  - name: ping_pong_service
    connect_timeout: 0.25s
    type: logical_dns
    http2_protocol_options: {}
    lb_policy: round_robin
    hosts: [{ socket_address: { address: host.docker.internal, port_value: 8080 }}]
</code></pre>
<p>现在，使用以下命令构建我们的Docker映像：</p>
<pre><code>docker build -t mohak1712/learn-grpc-web .
</code></pre>
<p>现在让我们运行docker镜像：</p>
<pre><code>docker run -d -p 9090:9090 mohak1712/learn-grpc-web
</code></pre>
<p>我们需要将主机端口9090转发到容器端口9090，以便将端口9090上的任何请求转发到运行envoy的docker容器。</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://jiannanh.github.io/post/leetcode-mu-lu-ye-mian/">
                  <h3 class="post-title">
                    leetcode目录页面
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
